var documenterSearchIndex = {"docs":
[{"location":"details/#Details-of-Algorithms","page":"Details","title":"Details of Algorithms","text":"","category":"section"},{"location":"details/#Correlation-Conversion","page":"Details","title":"Correlation Conversion","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target Spearman's rho or Kendall's tau correlation","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Determine the Pearson correlation for use in a Gaussian copula such that the resulting random samples using the NORTA algorithm have an estimated Spearman or Kendall correlation that matches the target correlation","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"From Proposition 22 (Lebrun and Dutfow, 2009), we have the result for Gaussian copula that the copula correlation r is related to Spearman's rho and Kendall's tau by the following relations:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"r = 2 sin left(fracpi6 rhoright) \nr = sin left(fracpi2 tauright)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Lebrun, R., & Dutfoy, A. (2009). An innovating analysis of the Nataf transformation from the copula viewpoint. Probabilistic Engineering Mechanics, 24(3), 312-320.","category":"page"},{"location":"details/#Pearson-Matching","page":"Details","title":"Pearson Matching","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target Pearson correlation matrix, R\nA list of marginal distributions, F","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Determine the input correlation, tildeP, such that the resulting random samples using the NORTA algorithm have an estimated Pearson correlation that matches P","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"This method relies on Equations 19, 39, and 49 (Xiao and Zhou, 2019).","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Xiao, Q., & Zhou, S. (2019). Matching a correlation coefficient by a Gaussian copula. Communications in Statistics-Theory and Methods, 48(7), 1728-1747.","category":"page"},{"location":"details/#Nearest-Correlation-Matrix","page":"Details","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"This algorithm is trying to find a correlation matrix X close to G in the convex optimization problem:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"beginaligned\n    mathrmminquad  frac12 Vert G - X Vert^2 \n    mathrmstquad  X_ii = 1 quad i = 1 ldots  n \n     X in S_+^n\nendaligned","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Qi, H., & Sun, D. (2006). A quadratically convergent Newton method for computing the nearest correlation matrix. SIAM journal on matrix analysis and applications, 28(2), 360-385.","category":"page"},{"location":"details/#Normal-to-Anything-(NORTA)","page":"Details","title":"Normal to Anything (NORTA)","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target correlation matrix, rho\nA list of marginal distributions, F","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Generate Z_n times d = mathcalN(0 1) IID standard normal samples\nTransform Y = ZC where C is the upper Cholesky factor of rho\nTransform U = Phi(Y) where Phi(cdot) is the CDF of the standard normal distribution\nTransform X_i = F_i^-1(U_i)","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Plots, PrettyTables\ngr()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We’re going to show the basic use and syntax of Bigsimr by using the New York air quality data set (airquality) included in the RDatasets package. We will focus specifically on the temperature (degrees Fahrenheit) and ozone level (parts per billion).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Bigsimr, Distributions\nusing RDatasets, DataFrames, Statistics","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df = dataset(\"datasets\", \"airquality\")[:, [:Ozone, :Temp]] |> dropmissing\npretty_table(df, tf=tf_markdown, show_row_number=true, vcrop_mode=:middle, display_size=(13, 80)) # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let’s look at the joint distribution of the Ozone and Temperature","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"temp_ozone = scatter(df.:Temp, df.:Ozone, legend=false, xguide=\"Temperature (F)\", yguide=\"Ozone (PPB)\") # hide\nhist_temp  = histogram(df.:Temp, label=\"Temperature\", bins=30) # hide\nhist_ozone = histogram(df.:Ozone, label=\"Ozone\", bins=30) # hide\nl = @layout [a{0.7w} grid(2, 1)] # hide\nplot(temp_ozone, hist_temp, hist_ozone, layout=l) # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can see that not all margins are normally distributed; the ozone level is highly skewed. Though we don’t know the true distribution of ozone levels, we can go forward assuming that it is log-normally distributed.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To simulate observations from this joint distribution, we need to estimate the correlation and the marginal parameters.","category":"page"},{"location":"getting_started/#Estimating-Correlation","page":"Getting Started","title":"Estimating Correlation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To estimate the correlation, we use cor with an argument specifying the type of correlation to estimate. The options are Pearson, Spearman, or Kendall.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ρ = cor(Matrix(df), Pearson)","category":"page"},{"location":"getting_started/#Defining-Marginal-Distributions","page":"Getting Started","title":"Defining Marginal Distributions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next we can estimate the marginal parameters. Assuming that the Temperature is normally distributed, it has parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"μ_Temp = mean(df.Temp)\nσ_Temp = std(df.Temp)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and assuming that Ozone is log-normally distributed, it has parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"μ_Ozone = mean(log.(df.Ozone))\nσ_Ozone = sqrt(mean((log.(df.Ozone) .- mean(log.(df.Ozone))).^2))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally we take the parameters and put them into a vector of margins:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"margins = [Normal(μ_Temp, σ_Temp), LogNormal(μ_Ozone, σ_Ozone)]","category":"page"},{"location":"getting_started/#Correlation-Bounds","page":"Getting Started","title":"Correlation Bounds","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Given a vector of margins, the theoretical lower and upper correlation coefficients can be estimated using simulation:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"lower, upper = cor_bounds(D);\nlower\nupper","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The pearson_bounds function uses more sophisticated methods to determine the theoretical lower and upper Pearson correlation bounds. It also requires more computational time.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"lower, upper = pearson_bounds(D);\nlower\nupper","category":"page"},{"location":"getting_started/#Simulating-Multivariate-Data","page":"Getting Started","title":"Simulating Multivariate Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let’s now simulate 10,000 observations from the joint distribution using rvec:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = rvec(10_000, ρ, margins)","category":"page"},{"location":"getting_started/#Visualizing-Bivariate-Data","page":"Getting Started","title":"Visualizing Bivariate Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df_sim = DataFrame(x, [:Temp, :Ozone]);\n\nhistogram2d(df_sim.:Temp, df_sim.:Ozone, nbins=250, legend=false,\n\t\t\txlims=extrema(df.:Temp) .+ (-10, 10), \n\t\t\tylims=extrema(df.:Ozone) .+ (0, 20))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Compared to Uncorrelated Samples","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can compare the bivariate distribution above to one where no correlation is taken into account.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df_sim2 = DataFrame(\n\tTemp  = rand(margins[1], 10000), \n\tOzone = rand(margins[2], 10000)\n);\n\nhistogram2d(df_sim2.:Temp, df_sim2.:Ozone, nbins=250, legend=false,\n\t\t\txlims=extrema(df.:Temp) .+ (-10, 10), \n\t\t\tylims=extrema(df.:Ozone) .+ (0, 20))","category":"page"},{"location":"nearest_correlation_matrix/#Nearest-Correlation-Matrix","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"using Bigsimr, JLD, LinearAlgebra, BenchmarkTools\nusing Statistics, Distributions\n\ntmp_dir = mktempdir()\ntarball = \"assets/brca200.tar.xz\"\nrun(`tar -xf $tarball -C $tmp_dir`)\nbrca = JLD.load(joinpath(tmp_dir, \"brca200.jld\"), \"brca200\")\n\nfunction fit_mom(x)\n    μ = mean(x)\n    σ = std(x)\n    r = μ^2 / (σ^2 - μ)\n    p = μ / σ^2\n    NegativeBinomial(r, p)\nend\n\nmargins = [fit_mom(x) for x in eachcol(brca)]","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"Sometimes what we want really is the Spearman correlation. Then we don't need to do any Pearson matching. All we need to do is estimate/obtain the Spearman correlation of some data, convert it to Pearson, and then simulate. The resulting simulated data will have the same Spearman correlation as the one estimated from the data (up to stochastic error). The problem is that for high dimensional data, the Spearman or converted Pearson correlation matrix may not be positive semidefinite (PSD). The problem is then how to compute the nearest PSD correlation matrix.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We provide the function cor_nearPD to handle this problem. It is based off of the work of Qi and Sun (2006), and is a quadratically convergent algorithm. Here we use BRCA data to show its use.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m = Matrix(brca)\nτ = cor(m, Spearman);\nρₚ = cor_convert(τ, Spearman, Pearson);\nisposdef.([τ, ρₚ])","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We see that the converted Pearson correlation matrix is no longer positve definite. This will result in a failure during the multivariate normal generation, particularly during the Cholesky decomposition.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"rvec(10, ρₚ, margins)","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We can fix this by computing the nearest PD correlation.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"ρ̃ₚ = cor_nearPD(ρₚ); \nisposdef(ρ̃ₚ)\nrvec(10, ρ̃ₚ, margins)","category":"page"},{"location":"nearest_correlation_matrix/#Benchmarking","page":"Nearest Correlation Matrix","title":"Benchmarking","text":"","category":"section"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"What's more impressive is that computing the nearest correlation matrix in Julia is fast!","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_nearPD(ρₚ)\nBenchmarkTools.Trial: \n  memory estimate:  6.84 MiB\n  allocs estimate:  160652\n  --------------\n  minimum time:     8.485 ms (0.00% GC)\n  median time:      8.848 ms (0.00% GC)\n  mean time:        9.326 ms (4.77% GC)\n  maximum time:     13.108 ms (0.00% GC)\n  --------------\n  samples:          537\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"Let's scale up to a larger correlation matrix:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m3000 = cor_randPSD(3000) |> m -> cor_convert(m, Spearman, Pearson)\nm3000_PD = cor_nearPD(m3000);\nisposdef(m3000)\nisposdef(m3000_PD)","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_nearPD(m3000)\nBenchmarkTools.Trial: \n  memory estimate:  3.72 GiB\n  allocs estimate:  78433\n  --------------\n  minimum time:     11.460 s (2.31% GC)\n  median time:      11.460 s (2.31% GC)\n  mean time:        11.460 s (2.31% GC)\n  maximum time:     11.460 s (2.31% GC)\n  --------------\n  samples:          1\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"~12 seconds to convert a 3000x3000 correlation matrix! This even beats previous benchmarks for a 3000x3000 randomly generated pseudo correlation matrix. Here is an excert from Defeng Sun's home page where his matlab code is:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"For a randomly generated  3,000 by 3,000 pseudo correlation matrix (the code is insensitive to input data), the code needs 24 seconds to reach a solution with the relative duality gap less than 1.0e-3 after 3 iterations and 43 seconds  with the relative duality gap less than 1.0e-10 after 6 iterations in my Dell Desktop with Intel (R) Core i7 processor.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We also offer a faster routine that gives up a little accuracy for speed. While cor_nearPD finds the nearest correlation matrix to the input matrix, cor_fastPD finds a positive definite correlation matrix that is close to the input matrix.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_fastPD(m3000)\nBenchmarkTools.Trial: \n  memory estimate:  628.95 MiB\n  allocs estimate:  26035\n  --------------\n  minimum time:     2.037 s (0.58% GC)\n  median time:      2.093 s (1.75% GC)\n  mean time:        2.115 s (3.38% GC)\n  maximum time:     2.216 s (7.49% GC)\n  --------------\n  samples:          3\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"And it's not too far off from the nearest:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m3000_PD_fast = cor_fastPD(m3000);\nnorm(m3000 - m3000_PD)\nnorm(m3000 - m3000_PD_fast)","category":"page"},{"location":"function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#Bigsimr.jl-Package","page":"Bigsimr.jl","title":"Bigsimr.jl Package","text":"","category":"section"},{"location":"","page":"Bigsimr.jl","title":"Bigsimr.jl","text":"The Bigsimr package provides a helpful set of tools for simulating high-dimensional multivariate data with arbitrary marginal distributions. Particularly, Bigsimr implements:","category":"page"},{"location":"","page":"Bigsimr.jl","title":"Bigsimr.jl","text":"Simulation of multivariate data via Gaussian copulas (NORTA algorithm)\nConverting between different types of correlations (Pearson, Spearman, and Kendall)\nComputing the nearest positive definite correlation matrix (quadratically convergent algorithm)\nPearson correlation matching to account for non-linear transformations\nGenerating random positive semi-definite correlation matrices","category":"page"},{"location":"main_functions/#Main-Functions","page":"Main Functions","title":"Main Functions","text":"","category":"section"},{"location":"main_functions/#Random-Multivariate-Vector","page":"Main Functions","title":"Random Multivariate Vector","text":"","category":"section"},{"location":"main_functions/#Functions","page":"Main Functions","title":"Functions","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"rvec\nrmvn","category":"page"},{"location":"main_functions/#Bigsimr.rvec","page":"Main Functions","title":"Bigsimr.rvec","text":"rvec(n, ρ::Matrix, margins::Vector{<:UnivariateDistribution})\n\nGenerate samples for a list of marginal distributions and a correaltion structure.\n\nExamples\n\njulia> using Distributions\n\njulia> import LinearAlgebra: diagind\n\njulia> margins = [Normal(3, 1), LogNormal(3, 1), Exponential(3)]\n\njulia> R = fill(0.5, 3, 3); r[diagind(r)] .= 1.0;\n\njulia> rvec(10, R, margins)\n#>10×3 Array{Float64,2}:\n 3.71109  82.0696   8.14332\n 1.23022  38.8599   2.64595\n 2.07222   3.76843  1.13465\n 2.82434  11.6953   0.891066\n 2.37599  10.0552   1.80555\n 2.85431  25.4935   3.40865\n 3.85253  21.2241   3.67532\n 3.70605  59.2439   2.02502\n 2.34066   1.89257  0.619948\n 3.83507  16.787    0.66837\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.rmvn","page":"Main Functions","title":"Bigsimr.rmvn","text":"rmvn(n[, μ], Σ)\n\nFast parrallel generation of multivariate normal samples.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Correlations","page":"Main Functions","title":"Correlations","text":"","category":"section"},{"location":"main_functions/#Types","page":"Main Functions","title":"Types","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"Bigsimr.Pearson\nBigsimr.Spearman\nBigsimr.Kendall","category":"page"},{"location":"main_functions/#Bigsimr.Pearson","page":"Main Functions","title":"Bigsimr.Pearson","text":"Pearson <: Correlation\n\nPearson's r product-moment correlation\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#Bigsimr.Spearman","page":"Main Functions","title":"Bigsimr.Spearman","text":"Spearman <: Correlation\n\nSpearman's ρ rank correlation\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#Bigsimr.Kendall","page":"Main Functions","title":"Bigsimr.Kendall","text":"Kendall <: Correlation\n\nKendall's τ rank correlation\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#Estimating","page":"Main Functions","title":"Estimating","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"cor\ncor_fast\ncor_bounds","category":"page"},{"location":"main_functions/#Statistics.cor","page":"Main Functions","title":"Statistics.cor","text":"cor(x[, y], ::Type{<:Correlation})\n\nCompute the correlation matrix of a given type. \n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> x = [-1.62169     0.0158613   0.500375  -0.794381\n             2.50689     3.31666    -1.3049     2.16058\n             0.495674    0.348621   -0.614451  -0.193579\n             2.32149     2.18847    -1.83165    2.08399\n            -0.0573697   0.39908     0.270117   0.658458\n             0.365239   -0.321493   -1.60223   -0.199998\n            -0.55521    -0.898513    0.690267   0.857519\n            -0.356979   -1.03724     0.714859  -0.719657\n            -3.38438    -1.93058     1.77413   -1.23657\n             1.57527     0.836351   -1.13275   -0.277048];\n\njulia> cor(x, Pearson)\n4×4 Array{Float64,2}:\n  1.0        0.86985   -0.891312   0.767433\n  0.86985    1.0       -0.767115   0.817407\n -0.891312  -0.767115   1.0       -0.596762\n  0.767433   0.817407  -0.596762   1.0\n\njulia> cor(x, Spearman)\n4×4 Array{Float64,2}:\n  1.0        0.866667  -0.854545   0.709091\n  0.866667   1.0       -0.781818   0.684848\n -0.854545  -0.781818   1.0       -0.612121\n  0.709091   0.684848  -0.612121   1.0\n\njulia> cor(x, Kendall)\n4×4 Array{Float64,2}:\n  1.0        0.733333  -0.688889   0.555556\n  0.733333   1.0       -0.688889   0.555556\n -0.688889  -0.688889   1.0       -0.422222\n  0.555556   0.555556  -0.422222   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fast","page":"Main Functions","title":"Bigsimr.cor_fast","text":"cor_fast\n\nCalculate the correlation matrix in parallel.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_bounds","page":"Main Functions","title":"Bigsimr.cor_bounds","text":"cor_bounds(dA::UnivariateDistribution, dB::UnivariateDistribution, C::Type{<:Correlation}=Pearson; n_samples::Real=100_000)\n\nCompute the stochastic lower and upper correlation bounds between two marginal distributions.\n\nThis method relies on sampling from each distribution and then estimating the specified correlation between the sorted samples. Because the samples are random, there will be some variation in the answer for each call to cor_bounds. Increasing the number of samples will increase the accuracy of the estimate, but will also take longer to sort. Therefore ≈100,000 samples (the default) are recommended so that it runs fast while still returning a good estimate.\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> using Distributions\n\njulia> A = Normal(78, 10); B = LogNormal(3, 1);\n\njulia> cor_bounds(A, B)\n(lower = -0.7646512417819491, upper = 0.7649206069306482)\n\njulia> cor_bounds(A, B, n_samples=Int(1e9))\n(lower = -0.7629776825238167, upper = 0.7629762333824238)\n\njulia> cor_bounds(A, B, n_samples=Int(1e4))\n(lower = -0.7507010142250724, upper = 0.7551879647701095)\n\njulia> cor_bounds(A, B, Spearman)\n(lower = -1.0, upper = 1.0)\n\n\n\n\n\ncorbounds(margins::Vector{<:UD}, C::Type{<:Correlation}=Pearson; nsamples::Real=100_000)\n\nCompute the stochastic pairwise lower and upper correlation bounds between a set of marginal distributions.\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Generating","page":"Main Functions","title":"Generating","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"cor_randPSD\ncor_randPD","category":"page"},{"location":"main_functions/#Bigsimr.cor_randPSD","page":"Main Functions","title":"Bigsimr.cor_randPSD","text":"cor_randPSD([T::Type{<:AbstractFloat}], d::Int[, k::Int=d])\n\nReturn a random positive semidefinite correlation matrix.\n\nSee also: cor_randPD\n\nExamples\n\njulia> cor_randPSD(Float64, 4, 2)\n#>4×4 Array{Float64,2}:\n 1.0        0.276386   0.572837   0.192875\n 0.276386   1.0        0.493806  -0.352386\n 0.572837   0.493806   1.0       -0.450259\n 0.192875  -0.352386  -0.450259   1.0\n\njulia> cor_randPSD(4, 1)\n4×4 Array{Float64,2}:\n1.0       -0.800513   0.541379  -0.650587\n-0.800513   1.0       -0.656411   0.788824\n0.541379  -0.656411   1.0       -0.533473\n-0.650587   0.788824  -0.533473   1.0\n\njulia> cor_randPSD(4)\n4×4 Array{Float64,2}:\n  1.0        0.81691   -0.27188    0.289011\n  0.81691    1.0       -0.44968    0.190938\n -0.27188   -0.44968    1.0       -0.102597\n  0.289011   0.190938  -0.102597   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_randPD","page":"Main Functions","title":"Bigsimr.cor_randPD","text":"cor_randPD([T::Type{<:AbstractFloat}], d::Int[, k::Int=d])\n\nThe same as cor_randPSD, but calls cor_fastPD to ensure that the returned matrix is positive definite.\n\nExamples\n\njulia> cor_randPD(Float64, 4, 2)\n#>4×4 Array{Float64,2}:\n  1.0        0.458549  -0.33164    0.492572\n  0.458549   1.0       -0.280873   0.62544\n -0.33164   -0.280873   1.0       -0.315011\n  0.492572   0.62544   -0.315011   1.0\n\njulia> cor_randPD(4, 1)\n4×4 Array{Float64,2}:\n  1.0        -0.0406469  -0.127517  -0.133308\n  -0.0406469   1.0         0.265604   0.277665\n  -0.127517    0.265604    1.0        0.871089\n  -0.133308    0.277665    0.871089   1.0\n\njulia> cor_randPD(4)\n4×4 Array{Float64,2}:\n  1.0        0.356488   0.701521  -0.251671\n  0.356488   1.0        0.382787  -0.117748\n  0.701521   0.382787   1.0       -0.424952\n -0.251671  -0.117748  -0.424952   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Converting","page":"Main Functions","title":"Converting","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"Convert a correlation matrix by finding a positive [semi]definite representation.","category":"page"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"cor_nearPD\ncor_fastPD\ncor_fastPD!","category":"page"},{"location":"main_functions/#Bigsimr.cor_nearPD","page":"Main Functions","title":"Bigsimr.cor_nearPD","text":"cor_nearPD(R::Matrix{T}[, τ::Real=1e-6[, tol::Real=1e-6]]) where {T<:AbstractFloat}\n\nReturn the nearest positive definite correlation matrix to R.\n\nSee also: cor_fastPD, cor_fastPD!\n\nExamples\n\njulia> import LinearAlgebra: isposdef\n\njulia> r = [1.00 0.82 0.56 0.44; 0.82 1.00 0.28 0.85; 0.56 0.28 1.00 0.22; 0.44 0.85 0.22 1.00]\n4×4 Array{Float64,2}:\n 1.0   0.82  0.56  0.44\n 0.82  1.0   0.28  0.85\n 0.56  0.28  1.0   0.22\n 0.44  0.85  0.22  1.0\n\njulia> isposdef(r)\nfalse\n\njulia> p = cor_nearPD(r)\n4×4 Array{Float64,2}:\n 1.0       0.817494  0.559416  0.441494\n 0.817494  1.0       0.280852  0.847812\n 0.559416  0.280852  1.0       0.21949\n 0.441494  0.847812  0.21949   1.0\n\njulia> isposdef(p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fastPD","page":"Main Functions","title":"Bigsimr.cor_fastPD","text":"cor_fastPD(R::Matrix{<:AbstractFloat}[, τ=1e-6])\n\nReturn a positive definite correlation matrix that is close to R.\n\nSee also: cor_fastPD!, cor_nearPD\n\nExamples\n\njulia> import LinearAlgebra: isposdef\n\njulia> r = [1.00 0.82 0.56 0.44; 0.82 1.00 0.28 0.85; 0.56 0.28 1.00 0.22; 0.44 0.85 0.22 1.00]\n4×4 Array{Float64,2}:\n 1.0   0.82  0.56  0.44\n 0.82  1.0   0.28  0.85\n 0.56  0.28  1.0   0.22\n 0.44  0.85  0.22  1.0\n\njulia> isposdef(r)\nfalse\n\njulia> p = cor_fastPD(r)\n4×4 Array{Float64,2}:\n 1.0       0.817095  0.559306  0.440514\n 0.817095  1.0       0.280196  0.847352\n 0.559306  0.280196  1.0       0.219582\n 0.440514  0.847352  0.219582  1.0\n\njulia> isposdef(p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fastPD!","page":"Main Functions","title":"Bigsimr.cor_fastPD!","text":"cor_fastPD!(R::Matrix{<:AbstractFloat}[, τ=1e-6])\n\nSame as cor_fastPD, but saves space by overwriting the input R, instead of creating a copy.\n\nSee also: cor_fastPD, cor_nearPD\n\nExamples\n\njulia> import LinearAlgebra: isposdef\n\njulia> r = [1.00 0.82 0.56 0.44; 0.82 1.00 0.28 0.85; 0.56 0.28 1.00 0.22; 0.44 0.85 0.22 1.00]\n4×4 Array{Float64,2}:\n 1.0   0.82  0.56  0.44\n 0.82  1.0   0.28  0.85\n 0.56  0.28  1.0   0.22\n 0.44  0.85  0.22  1.0\n\njulia> isposdef(r)\nfalse\n\njulia> cor_fastPD!(r)\n\njulia> isposdef(r)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"Convert a correlation matrix using other utilities.","category":"page"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"cor_convert\ncov2cor\ncov2cor!\ncor_constrain\ncor_constrain!","category":"page"},{"location":"main_functions/#Bigsimr.cor_convert","page":"Main Functions","title":"Bigsimr.cor_convert","text":"cor_convert(X::Matrix{<:Real}, from::Type{<:Correlation}, to::Type{<:Correlation})\n\nConvert from one type of correlation matrix to another.\n\nThe role of conversion in this package is typically used from either Spearman or  Kendall to Pearson where the Pearson correlation is used in the generation of random multivariate normal samples. After converting, the correlation matrix may not be positive semidefinite, so it is recommended to check using  LinearAlgebra.isposdef, and subsequently calling cor_nearPD.\n\nSee also: cor_nearPD, cor_fastPD\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> r = [ 1.0       -0.634114   0.551645   0.548993\n            -0.634114   1.0       -0.332105  -0.772114\n             0.551645  -0.332105   1.0        0.143949\n             0.548993  -0.772114   0.143949   1.0];\n\njulia> cor_convert(r, Pearson, Spearman)\n4×4 Array{Float64,2}:\n  1.0       -0.616168   0.533701   0.531067\n -0.616168   1.0       -0.318613  -0.756979\n  0.533701  -0.318613   1.0        0.13758\n  0.531067  -0.756979   0.13758    1.0\n\njulia> cor_convert(r, Spearman, Kendall)\n4×4 Array{Float64,2}:\n  1.0       -0.452063   0.385867    0.383807\n -0.452063   1.0       -0.224941   -0.576435\n  0.385867  -0.224941   1.0         0.0962413\n  0.383807  -0.576435   0.0962413   1.0\n\njulia> r == cor_convert(r, Pearson, Pearson)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cov2cor","page":"Main Functions","title":"Bigsimr.cov2cor","text":"cov2cor(C::Matrix{<:AbstractFloat})\n\nTransform a covariance matrix into a correlation matrix.\n\nDetails\n\nIf X in mathbbR^n times n is a covariance matrix, then\n\ntildeX = D^-12 X  D^-12 quad D = mathrmdiag(X)\n\nis the associated correlation matrix.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cov2cor!","page":"Main Functions","title":"Bigsimr.cov2cor!","text":"cov2cor!(C::Matrix{<:AbstractFloat})\n\nSame as cov2cor, except that the matrix C is updated in place to save memory.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_constrain","page":"Main Functions","title":"Bigsimr.cor_constrain","text":"cor_constrain(C::Matrix{<:Real}[, uplo=:U])\n\nConstrain a matrix so that its diagonal elements are 1, off-diagonal elements are bounded between -1 and 1, and a symmetric view of the upper (if uplo = :U) or lower (if uplo = :L) triangle is made.\n\nSee also: cor_constrain!\n\nExamples\n\njulia> a = [ 0.802271   0.149801  -1.1072     1.13451\n             0.869788  -0.824395   0.38965    0.965936\n            -1.45353   -1.29282    0.417233  -0.362526\n             0.638291  -0.682503   1.12092   -1.27018];\n\njulia> cor_constrain(a)\n4×4 Array{Float64,2}:\n  1.0       0.149801  -1.0        1.0\n  0.149801  1.0        0.38965    0.965936\n -1.0       0.38965    1.0       -0.362526\n  1.0       0.965936  -0.362526   1.0\n\njulia> cor_constrain(a, :L)\n4×4 Array{Float64,2}:\n  1.0        0.869788  -1.0   0.638291\n  0.869788   1.0       -1.0  -0.682503\n -1.0       -1.0        1.0   1.0\n  0.638291  -0.682503   1.0   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_constrain!","page":"Main Functions","title":"Bigsimr.cor_constrain!","text":"cor_constrain!(C::Matrix{<:Real}[, uplo=:U])\n\nSame as cor_constrain, except that the matrix C is updated in place to save memory.\n\nExamples\n\njulia> a = [ 0.802271   0.149801  -1.1072     1.13451\n             0.869788  -0.824395   0.38965    0.965936\n            -1.45353   -1.29282    0.417233  -0.362526\n             0.638291  -0.682503   1.12092   -1.27018];\n\njulia> cor_constrain!(a)\n\njulia> a\n4×4 Array{Float64,2}:\n  1.0       0.149801  -1.0        1.0\n  0.149801  1.0        0.38965    0.965936\n -1.0       0.38965    1.0       -0.362526\n  1.0       0.965936  -0.362526   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Pearson-Matching","page":"Main Functions","title":"Pearson Matching","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"pearson_match\npearson_bounds","category":"page"},{"location":"main_functions/#Bigsimr.pearson_match","page":"Main Functions","title":"Bigsimr.pearson_match","text":"pearson_match(ρ::Float64, dA::UnivariateDistribution, dB::UnivariateDistribution; n::Int=7)\n\nCompute the pearson correlation coefficient that is necessary to achieve the target correlation given a pair of marginal distributions.\n\nSee also: pearson_bounds\n\nExamples\n\njulia> using Distributions\n\njulia> A = Normal(78, 10); B = LogNormal(3, 1);\n\njulia> pearson_match(0.76, A, B)\n0.9962326957682248\n\nThe target correlation may not be feasible (see pearson_bounds), in  which case the match to the nearest lower or upper bound is returned.\n\njulia> pearson_match(0.9, A, B)\n┌ Warning: The target correlation is not feasible. Returning the match to the nearest bound instead.\n[...]\n0.9986891675056113\n\n\n\n\n\npearson_match(ρ::Matrix{Float64}, margins::Vector{<:UD})\n\nCompute the pearson correlation coefficient that is necessary to achieve the target correlation matrix given a set of marginal distributions.\n\nSee also: pearson_bounds\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.pearson_bounds","page":"Main Functions","title":"Bigsimr.pearson_bounds","text":"pearson_bounds(dA::UnivariateDistribution, dB::UnivariateDistribution; n::Int=7)\n\nCompute the theoretical lower and upper Pearson correlation values for a pair of  univariate distributions.\n\nSee also: pearson_match\n\nExamples\n\njulia> using Distributions\n\njulia> A = Normal(78, 10); B = LogNormal(3, 1);\n\njulia> pearson_bounds(A, B)\n(lower = -0.7628739783668452, upper = 0.762873978367046)\n\n\n\n\n\npearson_bounds(margins::Vector{<:UnivariateDistribution})\n\nCompute the theoretical lower and upper Pearson correlation values for a set of  univariate distributions.\n\nSee also: pearson_match\n\nExamples\n\njulia> using Distributions\n\njulia> m = [Normal(78, 10), LogNormal(3, 1)];\n\njulia> b = pearson_bounds(m);\n\njulia> b.lower\n2×2 Array{Float64,2}:\n  1.0       -0.762874\n -0.762874   1.0\n\njulia> b.upper\n2×2 Array{Float64,2}:\n 1.0       0.762874\n 0.762874  1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Generalized-S-Distribution-(Experimental)","page":"Main Functions","title":"Generalized S-Distribution (Experimental)","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"Bigsimr.GSDistribution","category":"page"},{"location":"main_functions/#Bigsimr.GSDistribution","page":"Main Functions","title":"Bigsimr.GSDistribution","text":"GSDistribution\n\nGeneralized S-Distribution.\n\n\n\n\n\n","category":"type"},{"location":"pearson_matching/#Pearson-Matching","page":"Pearson Matching","title":"Pearson Matching","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"using Bigsimr, Distributions\nusing RDatasets, DataFrames, Statistics\nusing Plots, PrettyTables\ngr()\ndf = dataset(\"datasets\", \"airquality\")[:, [:Ozone, :Temp]] |> dropmissing\nρ = cor(Matrix(df), Pearson)\nμ_Temp = mean(df.Temp)\nσ_Temp = std(df.Temp)\nμ_Ozone = mean(log.(df.Ozone))\nσ_Ozone = sqrt(mean((log.(df.Ozone) .- mean(log.(df.Ozone))).^2))\nmargins = [Normal(μ_Temp, σ_Temp), LogNormal(μ_Ozone, σ_Ozone)]","category":"page"},{"location":"pearson_matching/#Correlation-Conversion","page":"Pearson Matching","title":"Correlation Conversion","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Let's say we really wanted to estimate the Spearman correlation between the temperature and ozone.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"ρ_s = cor(Matrix(df), Spearman)\ncor_bounds(margins[1], margins[2], Spearman)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"If we just use the Spearman correlation when we simulate data, then the errors are double.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"The NORTA algorithm is expecting a Pearson correlation\nThe non-linear transformation in the NORTA step does not guarantee that the input correlation is the same as the output.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Here is what we get when we use the Spearman correlation directly with no transformation:","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"x_2 = rvec(1_000_000, ρ_s, margins);\ncor(x_2, Spearman)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Let's try to address issue 1 and convert the Spearman correlation to a Pearson correlation.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"ρ_p = cor_convert(ρ_s, Spearman, Pearson);\nx_3 = rvec(1_000_000, ρ_p, margins);\ncor(x_3, Spearman)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Notice that the estimated Spearman correlation is essentially the same as the target Spearman correlation. This is because the transformation in the NORTA step is monotonic, which means that rank-based correlations are preserved. As a consequence, we can match the Spearman correlation exactly (up to stochastic error) with an explicit transformation.","category":"page"},{"location":"pearson_matching/#Pearson-Matching-2","page":"Pearson Matching","title":"Pearson Matching","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"We can employ a Pearson matching algorithm that determines the necessary input correlation in order to achieve the target Pearson correlation. Let's now address issue 2.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"ρ = cor(Matrix(df), Pearson)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"If we use the measured correlation directly, then the estimated correlation from the simulated data is far off:","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"x_4 = rvec(1_000_000, ρ, margins);\ncor(x_4, Pearson)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"The estimated correlation is much too low. Let's do some Pearson matching and observe the results.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"p = pearson_match(ρ, margins)\nx_5 = rvec(1_000_000, p, margins);\ncor(x_5)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Now the simulated data results in a correlation structure that exactly matches the target Pearson correlation!","category":"page"}]
}
