var documenterSearchIndex = {"docs":
[{"location":"details/#Details-of-Algorithms","page":"Details","title":"Details of Algorithms","text":"","category":"section"},{"location":"details/#Correlation-Conversion","page":"Details","title":"Correlation Conversion","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target Spearman's rho or Kendall's tau correlation","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Determine the Pearson correlation for use in a Gaussian copula such that the resulting random samples using the NORTA algorithm have an estimated Spearman or Kendall correlation that matches the target correlation","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"From Proposition 22 (Lebrun and Dutfow, 2009), we have the result for Gaussian copula that the copula correlation r is related to Spearman's rho and Kendall's tau by the following relations:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"r = 2 sin left(fracpi6 rhoright) \nr = sin left(fracpi2 tauright)","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Lebrun, R., & Dutfoy, A. (2009). An innovating analysis of the Nataf transformation from the copula viewpoint. Probabilistic Engineering Mechanics, 24(3), 312-320.","category":"page"},{"location":"details/#Pearson-Matching","page":"Details","title":"Pearson Matching","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target Pearson correlation matrix, R\nA list of marginal distributions, F","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Determine the input correlation, tildeP, such that the resulting random samples using the NORTA algorithm have an estimated Pearson correlation that matches P","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"This method relies on Equations 19, 39, and 49 (Xiao and Zhou, 2019).","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Xiao, Q., & Zhou, S. (2019). Matching a correlation coefficient by a Gaussian copula. Communications in Statistics-Theory and Methods, 48(7), 1728-1747.","category":"page"},{"location":"details/#Nearest-Correlation-Matrix","page":"Details","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"This algorithm is trying to find a correlation matrix X close to G in the convex optimization problem:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"beginaligned\n    mathrmminquad  frac12 Vert G - X Vert^2 \n    mathrmstquad  X_ii = 1 quad i = 1 ldots  n \n     X in S_+^n\nendaligned","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Qi, H., & Sun, D. (2006). A quadratically convergent Newton method for computing the nearest correlation matrix. SIAM journal on matrix analysis and applications, 28(2), 360-385.","category":"page"},{"location":"details/#Normal-to-Anything-(NORTA)","page":"Details","title":"Normal to Anything (NORTA)","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target correlation matrix, rho\nA list of marginal distributions, F","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Generate Z_n times d = mathcalN(0 1) IID standard normal samples\nTransform Y = ZC where C is the upper Cholesky factor of rho\nTransform U = Phi(Y) where Phi(cdot) is the CDF of the standard normal distribution\nTransform X_i = F_i^-1(U_i)","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Plots, PrettyTables\ngr()","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We’re going to show the basic use and syntax of Bigsimr by using the New York air quality data set (airquality) included in the RDatasets package. We will focus specifically on the temperature (degrees Fahrenheit) and ozone level (parts per billion).","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Distributions, Bigsimr\nusing RDatasets, DataFrames, Statistics","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df = dataset(\"datasets\", \"airquality\")[:, [:Ozone, :Temp]] |> dropmissing;","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"| Row | Ozone |  Temp |\n|     | Int64 | Int64 |\n|-----|-------|-------|\n|   1 |    41 |    67 |\n|   2 |    36 |    72 |\n|   3 |    12 |    74 |\n|  ⋮  |   ⋮   |   ⋮   |\n| 114 |    14 |    75 |\n| 115 |    18 |    76 |\n| 116 |    20 |    68 |\n       110 rows omitted","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let’s look at the joint distribution of the Ozone and Temperature","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"temp_ozone = scatter(df.:Temp, df.:Ozone, legend=false, xguide=\"Temperature (F)\", yguide=\"Ozone (PPB)\") # hide\nhist_temp  = histogram(df.:Temp, label=\"Temperature\", bins=30) # hide\nhist_ozone = histogram(df.:Ozone, label=\"Ozone\", bins=30) # hide\nl = @layout [a{0.7w} grid(2, 1)] # hide\nplot(temp_ozone, hist_temp, hist_ozone, layout=l) # hide","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can see that not all margins are normally distributed; the ozone level is highly skewed. Though we don’t know the true distribution of ozone levels, we can go forward assuming that it is log-normally distributed.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To simulate observations from this joint distribution, we need to estimate the correlation and the marginal parameters.","category":"page"},{"location":"getting_started/#Estimating-Correlation","page":"Getting Started","title":"Estimating Correlation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To estimate the correlation, we use cor with an argument specifying the type of correlation to estimate. The options are Pearson, Spearman, or Kendall.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"ρ = cor(Pearson, Matrix(df))","category":"page"},{"location":"getting_started/#Defining-Marginal-Distributions","page":"Getting Started","title":"Defining Marginal Distributions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Next we can estimate the marginal parameters. Assuming that the Temperature is normally distributed, it has parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"μ_Temp = mean(df.Temp)\nσ_Temp = std(df.Temp)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"and assuming that Ozone is log-normally distributed, it has parameters:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"μ_Ozone = mean(log.(df.Ozone))\nσ_Ozone = sqrt(mean((log.(df.Ozone) .- mean(log.(df.Ozone))).^2))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally we take the parameters and put them into a vector of margins:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"margins = [Normal(μ_Temp, σ_Temp), LogNormal(μ_Ozone, σ_Ozone)]","category":"page"},{"location":"getting_started/#Correlation-Bounds","page":"Getting Started","title":"Correlation Bounds","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Given a vector of margins, the theoretical lower and upper correlation coefficients can be estimated using simulation:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"lower, upper = cor_bounds(margins, Pearson);\nlower\nupper","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The pearson_bounds function uses more sophisticated methods to determine the theoretical lower and upper Pearson correlation bounds. It also requires more computational time.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"lower, upper = pearson_bounds(margins);\nlower\nupper","category":"page"},{"location":"getting_started/#Simulating-Multivariate-Data","page":"Getting Started","title":"Simulating Multivariate Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let’s now simulate 10,000 observations from the joint distribution using rvec:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"x = rvec(10_000, ρ, margins)","category":"page"},{"location":"getting_started/#Visualizing-Bivariate-Data","page":"Getting Started","title":"Visualizing Bivariate Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df_sim = DataFrame(x, [:Temp, :Ozone]);\n\nhistogram2d(df_sim.:Temp, df_sim.:Ozone, nbins=250, legend=false,\n\t\t\txlims=extrema(df.:Temp) .+ (-10, 10), \n\t\t\tylims=extrema(df.:Ozone) .+ (0, 20))","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Compared to Uncorrelated Samples","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We can compare the bivariate distribution above to one where no correlation is taken into account.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"df_sim2 = DataFrame(\n\tTemp  = rand(margins[1], 10000), \n\tOzone = rand(margins[2], 10000)\n);\n\nhistogram2d(df_sim2.:Temp, df_sim2.:Ozone, nbins=250, legend=false,\n\t\t\txlims=extrema(df.:Temp) .+ (-10, 10), \n\t\t\tylims=extrema(df.:Ozone) .+ (0, 20))","category":"page"},{"location":"nearest_correlation_matrix/#Nearest-Correlation-Matrix","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"using Bigsimr, JLD2, LinearAlgebra, BenchmarkTools\nusing Statistics, Distributions\n\nbrca = JLD2.load(\"assets/brca200.jld2\", \"brca\")\n\nfunction fit_mom(x)\n    μ = mean(x)\n    σ = std(x)\n    r = μ^2 / (σ^2 - μ)\n    p = μ / σ^2\n    NegativeBinomial(r, p)\nend\n\nmargins = [fit_mom(x) for x in eachcol(brca)]","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"Sometimes what we want really is the Spearman correlation. Then we don't need to do any Pearson matching. All we need to do is estimate/obtain the Spearman correlation of some data, convert it to Pearson, and then simulate. The resulting simulated data will have the same Spearman correlation as the one estimated from the data (up to stochastic error). The problem is that for high dimensional data, the Spearman or converted Pearson correlation matrix may not be positive semidefinite (PSD). The problem is then how to compute the nearest PSD correlation matrix.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We provide the function cor_nearPD to handle this problem. It is based off of the work of Qi and Sun (2006), and is a quadratically convergent algorithm. Here we use BRCA data to show its use.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m = Matrix(brca)\nspearman_corr = cor(Spearman, m);\npearson_corr = cor_convert(spearman_corr, Spearman, Pearson);\nisposdef(spearman_corr), isposdef(pearson_corr)","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We see that the converted Pearson correlation matrix is no longer positve definite. This will result in a failure during the multivariate normal generation, particularly during the Cholesky decomposition.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"rvec(10, pearson_corr, margins)","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We can fix this by computing the nearest PD correlation.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"adjusted_pearson_corr = cor_nearPD(pearson_corr); \nisposdef(adjusted_pearson_corr)\nrvec(10, adjusted_pearson_corr, margins)","category":"page"},{"location":"nearest_correlation_matrix/#Benchmarking","page":"Nearest Correlation Matrix","title":"Benchmarking","text":"","category":"section"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"What's more impressive is that computing the nearest correlation matrix in Julia is fast!","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_nearPD(pearson_corr)\nBenchmarkTools.Trial: \n  memory estimate:  7.15 MiB\n  allocs estimate:  160669\n  --------------\n  minimum time:     8.968 ms (0.00% GC)\n  median time:      9.274 ms (0.00% GC)\n  mean time:        9.752 ms (4.78% GC)\n  maximum time:     12.407 ms (23.64% GC)\n  --------------\n  samples:          513\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"Let's scale up to a larger correlation matrix:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m3000 = cor_randPSD(3000) |> m -> cor_convert(m, Spearman, Pearson)\nm3000_PD = cor_nearPD(m3000);\nisposdef(m3000)\nisposdef(m3000_PD)","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_nearPD(m3000)\nBenchmarkTools.Trial: \n  memory estimate:  3.95 GiB\n  allocs estimate:  78597\n  --------------\n  minimum time:     10.648 s (2.66% GC)\n  median time:      10.648 s (2.66% GC)\n  mean time:        10.648 s (2.66% GC)\n  maximum time:     10.648 s (2.66% GC)\n  --------------\n  samples:          1\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"~11 seconds^[using an AMD Ryzen 9 3900X with 32GB of RAM] to convert a 3000x3000 correlation matrix! This even beats previous benchmarks for a 3000x3000 randomly generated pseudo correlation matrix. Here is an excerpt from Defeng Sun's home page where his matlab code is:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"For a randomly generated  3,000 by 3,000 pseudo correlation matrix (the code is insensitive to input data), the code needs 24 seconds to reach a solution with the relative duality gap less than 1.0e-3 after 3 iterations and 43 seconds  with the relative duality gap less than 1.0e-10 after 6 iterations in my Dell Desktop with Intel (R) Core i7 processor.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"We also offer a faster routine that gives up a little accuracy for speed. While cor_nearPD finds the nearest correlation matrix to the input matrix, cor_fastPD finds a positive definite correlation matrix that is close to the input matrix.","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"julia> @benchmark cor_fastPD(m3000) samples=10 seconds=30\nBenchmarkTools.Trial: \n  memory estimate:  628.92 MiB\n  allocs estimate:  26040\n  --------------\n  minimum time:     1.949 s (0.00% GC)\n  median time:      1.998 s (1.15% GC)\n  mean time:        2.015 s (2.28% GC)\n  maximum time:     2.139 s (8.48% GC)\n  --------------\n  samples:          10\n  evals/sample:     1","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"And it's not too far off from the nearest:","category":"page"},{"location":"nearest_correlation_matrix/","page":"Nearest Correlation Matrix","title":"Nearest Correlation Matrix","text":"m3000_PD_fast = cor_fastPD(m3000);\nnorm(m3000 - m3000_PD)\nnorm(m3000 - m3000_PD_fast)","category":"page"},{"location":"function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#Bigsimr.jl-Package","page":"Bigsimr.jl","title":"Bigsimr.jl Package","text":"","category":"section"},{"location":"","page":"Bigsimr.jl","title":"Bigsimr.jl","text":"The Bigsimr package provides a helpful set of tools for simulating high-dimensional multivariate data with arbitrary marginal distributions. Particularly, Bigsimr implements:","category":"page"},{"location":"","page":"Bigsimr.jl","title":"Bigsimr.jl","text":"Simulation of multivariate data via Gaussian copulas (NORTA algorithm)\nConverting between different types of correlations (Pearson, Spearman, and Kendall)\nComputing the nearest positive definite correlation matrix (quadratically convergent algorithm)\nPearson correlation matching to account for non-linear transformations\nGenerating random positive semi-definite correlation matrices","category":"page"},{"location":"main_functions/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"main_functions/#Random-Vector-Generation","page":"API Reference","title":"Random Vector Generation","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"rvec\nrmvn","category":"page"},{"location":"main_functions/#Bigsimr.rvec","page":"API Reference","title":"Bigsimr.rvec","text":"rvec(n, rho, margins)\n\nGenerate samples for a list of marginal distributions and a correaltion structure.\n\nExamples\n\njulia> using Distributions\n\njulia> margins = [Normal(3, 1), LogNormal(3, 1), Exponential(3)]\n\njulia> R = [\n     1.00 -0.23  0.12\n    -0.23  1.00 -0.46\n     0.12 -0.46  1.00\n];\n\njulia> rvec(10, R, margins)\n10×3 Matrix{Float64}:\n 3.89423  38.6339    1.30088\n 5.87344  11.5582    5.25233\n 3.62383  20.4001    3.25627\n 3.65075   3.8316    4.48547\n 1.62223   9.95032   1.48367\n 3.42208  35.0998    0.644814\n 1.82689  58.417     0.580125\n 4.73678   4.75506  11.2741\n 1.92511   9.44913   0.651013\n 3.19883  39.3707    0.581781\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.rmvn","page":"API Reference","title":"Bigsimr.rmvn","text":"rmvn(n [, μ], Σ)\n\nUtilizes available threads for fast generation of multivariate normal samples.\n\nExamples\n\njulia> μ = [-3, 1, 10];\n\njulia> S = cor_randPD(3)\n3×3 Matrix{Float64}:\n  1.0        -0.663633  -0.0909108\n -0.663633    1.0        0.151582\n -0.0909108   0.151582   1.0\n\njulia> rmvn(10, μ, S)\n10×3 Matrix{Float64}:\n -1.32616   -1.02602     11.0202\n -3.59396    2.84145      8.84367\n -0.441537  -1.53279      8.82931\n -4.69202    2.84618     10.5977\n -2.63359    2.65779      9.8374\n -3.75917    2.07208      8.90139\n -3.00716    0.00897664  10.1173\n -3.00928    0.851214     9.74029\n -3.43021    0.402382     9.51274\n -1.77849    0.157933     9.15944\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Correlation-Types","page":"API Reference","title":"Correlation Types","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"CorType\nPearson\nSpearman\nKendall","category":"page"},{"location":"main_functions/#Bigsimr.BigsimrBase.CorType","page":"API Reference","title":"Bigsimr.BigsimrBase.CorType","text":"CorType\n\nA type used for specifiying the type of correlation. Supported correlations are:\n\nPearson\nSpearman\nKendall\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#Bigsimr.BigsimrBase.Pearson","page":"API Reference","title":"Bigsimr.BigsimrBase.Pearson","text":"Pearson\n\nPearson's r product-moment correlation\n\n\n\n\n\n","category":"constant"},{"location":"main_functions/#Bigsimr.BigsimrBase.Spearman","page":"API Reference","title":"Bigsimr.BigsimrBase.Spearman","text":"Spearman\n\nSpearman's ρ rank correlation\n\n\n\n\n\n","category":"constant"},{"location":"main_functions/#Bigsimr.BigsimrBase.Kendall","page":"API Reference","title":"Bigsimr.BigsimrBase.Kendall","text":"Kendall\n\nKendall's τ rank correlation\n\n\n\n\n\n","category":"constant"},{"location":"main_functions/#Correlation-Computation","page":"API Reference","title":"Correlation Computation","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"cor\ncor_fast\ncor_bounds","category":"page"},{"location":"main_functions/#Statistics.cor","page":"API Reference","title":"Statistics.cor","text":"cor(cortype, x [,y])\n\nCompute the correlation matrix of a given type.\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> x = [-1.62169     0.0158613   0.500375  -0.794381\n             2.50689     3.31666    -1.3049     2.16058\n             0.495674    0.348621   -0.614451  -0.193579\n             2.32149     2.18847    -1.83165    2.08399\n            -0.0573697   0.39908     0.270117   0.658458\n             0.365239   -0.321493   -1.60223   -0.199998\n            -0.55521    -0.898513    0.690267   0.857519\n            -0.356979   -1.03724     0.714859  -0.719657\n            -3.38438    -1.93058     1.77413   -1.23657\n             1.57527     0.836351   -1.13275   -0.277048];\n\njulia> cor(Pearson, x)\n4×4 Matrix{Float64}:\n  1.0        0.86985   -0.891312   0.767433\n  0.86985    1.0       -0.767115   0.817407\n -0.891312  -0.767115   1.0       -0.596762\n  0.767433   0.817407  -0.596762   1.0\n\njulia> cor(Spearman, x)\n4×4 Matrix{Float64}:\n  1.0        0.866667  -0.854545   0.709091\n  0.866667   1.0       -0.781818   0.684848\n -0.854545  -0.781818   1.0       -0.612121\n  0.709091   0.684848  -0.612121   1.0\n\njulia> cor(Kendall, x)\n4×4 Matrix{Float64}:\n  1.0        0.733333  -0.688889   0.555556\n  0.733333   1.0       -0.688889   0.555556\n -0.688889  -0.688889   1.0       -0.422222\n  0.555556   0.555556  -0.422222   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fast","page":"API Reference","title":"Bigsimr.cor_fast","text":"cor_fast([cortype,] X)\n\nCalculate the correlation matrix in parallel using available threads.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_bounds","page":"API Reference","title":"Bigsimr.cor_bounds","text":"cor_bounds(d1, d2, cortype, samples)\n\nCompute the stochastic lower and upper correlation bounds between two marginal distributions.\n\nThis method relies on sampling from each distribution and then estimating the specified correlation between the sorted samples. Because the samples are random, there will be some variation in the answer for each call to cor_bounds. Increasing the number of samples will increase the accuracy of the estimate, but will also take longer to sort. Therefore ≈100,000 samples (the default) are recommended so that it runs fast while still returning a good estimate.\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> using Distributions\n\njulia> A = Normal(78, 10); B = LogNormal(3, 1);\n\njulia> cor_bounds(A, B)\n(lower = -0.7646512417819491, upper = 0.7649206069306482)\n\njulia> cor_bounds(A, B, 1e6)\n(lower = -0.765850375468031, upper = 0.7655170605697716)\n\njulia> cor_bounds(A, B, Pearson)\n(lower = -0.7631871539735006, upper = 0.7624398609255689)\n\njulia> cor_bounds(A, B, Spearman, 250_000)\n(lower = -1.0, upper = 1.0)\n\n\n\n\n\ncor_bounds(margins, cortype, samples)\n\nCompute the stochastic pairwise lower and upper correlation bounds between a set of marginal distributions.\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> using Distributions\n\njulia> margins = [Normal(78, 10), Binomial(20, 0.2), LogNormal(3, 1)];\n\njulia> lower, upper = cor_bounds(margins, Pearson);\n\njulia> lower\n3×3 Matrix{Float64}:\n  1.0       -0.983111  -0.768184\n -0.983111   1.0       -0.702151\n -0.768184  -0.702151   1.0\n\njulia> upper\n3×3 Matrix{Float64}:\n 1.0       0.982471  0.766727\n 0.982471  1.0       0.798379\n 0.766727  0.798379  1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Random-Correlation-Matrix","page":"API Reference","title":"Random Correlation Matrix","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"cor_randPSD\ncor_randPD","category":"page"},{"location":"main_functions/#Bigsimr.cor_randPSD","page":"API Reference","title":"Bigsimr.cor_randPSD","text":"cor_randPSD([T,] d, k=d-1)\n\nReturn a random positive semidefinite correlation matrix where d is the dimension (d  1) and k is the number of factor loadings (1  k  d).\n\nSee also: cor_randPD\n\nExamples\n\njulia> cor_randPSD(Float64, 4, 2)\n4×4 Matrix{Float64}:\n 1.0        0.276386   0.572837   0.192875\n 0.276386   1.0        0.493806  -0.352386\n 0.572837   0.493806   1.0       -0.450259\n 0.192875  -0.352386  -0.450259   1.0\n\njulia> cor_randPSD(4, 1)\n4×4 Matrix{Float64}:\n1.0       -0.800513   0.541379  -0.650587\n-0.800513   1.0       -0.656411   0.788824\n0.541379  -0.656411   1.0       -0.533473\n-0.650587   0.788824  -0.533473   1.0\n\njulia> cor_randPSD(4)\n4×4 Matrix{Float64}:\n  1.0        0.81691   -0.27188    0.289011\n  0.81691    1.0       -0.44968    0.190938\n -0.27188   -0.44968    1.0       -0.102597\n  0.289011   0.190938  -0.102597   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_randPD","page":"API Reference","title":"Bigsimr.cor_randPD","text":"cor_randPD([T,] d, k=d-1)\n\nThe same as cor_randPSD, but calls cor_fastPD to ensure that the returned matrix is positive definite.\n\nExamples\n\njulia> cor_randPD(Float64, 4, 2)\n4×4 Matrix{Float64}:\n  1.0        0.458549  -0.33164    0.492572\n  0.458549   1.0       -0.280873   0.62544\n -0.33164   -0.280873   1.0       -0.315011\n  0.492572   0.62544   -0.315011   1.0\n\njulia> cor_randPD(4, 1)\n4×4 Matrix{Float64}:\n  1.0        -0.0406469  -0.127517  -0.133308\n  -0.0406469   1.0         0.265604   0.277665\n  -0.127517    0.265604    1.0        0.871089\n  -0.133308    0.277665    0.871089   1.0\n\njulia> cor_randPD(4)\n4×4 Matrix{Float64}:\n  1.0        0.356488   0.701521  -0.251671\n  0.356488   1.0        0.382787  -0.117748\n  0.701521   0.382787   1.0       -0.424952\n -0.251671  -0.117748  -0.424952   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Converting-Correlation-Types","page":"API Reference","title":"Converting Correlation Types","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"cor_convert","category":"page"},{"location":"main_functions/#Bigsimr.cor_convert","page":"API Reference","title":"Bigsimr.cor_convert","text":"cor_convert(X, from, to)\n\nConvert from one type of correlation matrix to another.\n\nThe role of conversion in this package is typically used from either Spearman or Kendall to Pearson where the Pearson correlation is used in the generation of random multivariate normal samples. After converting, the correlation matrix may not be positive semidefinite, so it is recommended to check using LinearAlgebra.isposdef, and subsequently calling cor_nearPD.\n\nSee also: cor_nearPD, cor_fastPD\n\nThe possible correlation types are:\n\nPearson\nSpearman\nKendall\n\nExamples\n\njulia> r = [ 1.0       -0.634114   0.551645   0.548993\n            -0.634114   1.0       -0.332105  -0.772114\n             0.551645  -0.332105   1.0        0.143949\n             0.548993  -0.772114   0.143949   1.0];\n\njulia> cor_convert(r, Pearson, Spearman)\n4×4 Matrix{Float64}:\n  1.0       -0.616168   0.533701   0.531067\n -0.616168   1.0       -0.318613  -0.756979\n  0.533701  -0.318613   1.0        0.13758\n  0.531067  -0.756979   0.13758    1.0\n\njulia> cor_convert(r, Spearman, Kendall)\n4×4 Matrix{Float64}:\n  1.0       -0.452063   0.385867    0.383807\n -0.452063   1.0       -0.224941   -0.576435\n  0.385867  -0.224941   1.0         0.0962413\n  0.383807  -0.576435   0.0962413   1.0\n\njulia> r == cor_convert(r, Pearson, Pearson)\ntrue\n\n\n\n\n\ncor_convert(X::AbstractMatrix, from, to)\n\nWhen the input is a matrix, it is assumed to be a correlation matrix, and the resulting matrix is also constrained to be a correlation matrix (e.g. unit diagonal and off-digonal elements constrained between -1 and 1).\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Correlation-Utils","page":"API Reference","title":"Correlation Utils","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"Convert a correlation matrix using other utilities.","category":"page"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"cor_constrain\ncor_constrain!\ncov2cor\ncov2cor!\nis_correlation","category":"page"},{"location":"main_functions/#Bigsimr.cor_constrain","page":"API Reference","title":"Bigsimr.cor_constrain","text":"cor_constrain(X::AbstractMatrix{<:Real})\n\nConstrain a matrix so that its diagonal elements are 1, off-diagonal elements are bounded between -1 and 1, and a symmetric view of the upper triangle is made.\n\nSee also: cor_constrain!\n\nExamples\n\njulia> a = [ 0.802271   0.149801  -1.1072     1.13451\n             0.869788  -0.824395   0.38965    0.965936\n            -1.45353   -1.29282    0.417233  -0.362526\n             0.638291  -0.682503   1.12092   -1.27018];\n\njulia> cor_constrain(a)\n4×4 Matrix{Float64}:\n  1.0       0.149801  -1.0        1.0\n  0.149801  1.0        0.38965    0.965936\n -1.0       0.38965    1.0       -0.362526\n  1.0       0.965936  -0.362526   1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_constrain!","page":"API Reference","title":"Bigsimr.cor_constrain!","text":"cor_constrain!(X::AbstractMatrix{<:Real})\n\nSame as cor_constrain, except that the matrix is updated in place to save memory.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cov2cor","page":"API Reference","title":"Bigsimr.cov2cor","text":"cov2cor(X::AbstractMatrix{<:Real})\n\nTransform a covariance matrix into a correlation matrix.\n\nDetails\n\nIf X in mathbbR^n times n is a covariance matrix, then\n\ntildeX = D^-12 X  D^-12 quad D = mathrmdiag(X)\n\nis the associated correlation matrix.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cov2cor!","page":"API Reference","title":"Bigsimr.cov2cor!","text":"cov2cor!(X::AbstractMatrix{<:Real})\n\nSame as cov2cor, except that the matrix is updated in place to save memory.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.is_correlation","page":"API Reference","title":"Bigsimr.is_correlation","text":"is_correlation(X)\n\nCheck if the given matrix passes all the checks required to be a valid correlation matrix.\n\nCriteria\n\nA matrix is a valid correlation matrix if:\n\nSquare\nSymmetric\nDiagonal elements are equal to 1\nOff diagonal elements are between -1 and 1\nIs positive definite\n\nExamples\n\njulia> x = rand(3, 3)\n3×3 Matrix{Float64}:\n 0.834446  0.183285  0.837872\n 0.637295  0.270709  0.458703\n 0.626566  0.736907  0.61903\n\njulia> is_correlation(x)\nfalse\n\njulia> x = cor_randPD(3)\n3×3 Matrix{Float64}:\n 1.0       0.190911  0.449104\n 0.190911  1.0       0.636305\n 0.449104  0.636305  1.0\n\njulia> is_correlation(x)\ntrue\n\njulia> r_negdef = [\n    1.00 0.82 0.56 0.44\n    0.82 1.00 0.28 0.85\n    0.56 0.28 1.00 0.22\n    0.44 0.85 0.22 1.00\n];\n\njulia> is_correlation(r_negdef)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Nearest-Correlation-Matrix","page":"API Reference","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"main_functions/#Provided-by-NearestCorrelationMatrix.jl","page":"API Reference","title":"Provided by NearestCorrelationMatrix.jl","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"NearestCorrelationMatrix.Newton\nNearestCorrelationMatrix.AlternatingProjections\nNearestCorrelationMatrix.DirectProjection","category":"page"},{"location":"main_functions/#NearestCorrelationMatrix.Newton","page":"API Reference","title":"NearestCorrelationMatrix.Newton","text":"NewtonNew(; tau, tol_cg, tol_ls, iter_cg, iter_ls)\n\nParameters\n\ntau: a tuning parameter controlling the smallest eigenvalue of the resulting matrix\ntol_cg: the tolerance used in the conjugate gradient method\ntol_ls: the tolerance used in the line search method\niter_cg: the max number of iterations in the conjugate gradient method\niter_ls: the max number of refinements during the Newton step\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#NearestCorrelationMatrix.AlternatingProjections","page":"API Reference","title":"NearestCorrelationMatrix.AlternatingProjections","text":"AlternatingProjections(; tau=0)\n\nThe alternating projections algorithm developed by Nick Higham.\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#NearestCorrelationMatrix.DirectProjection","page":"API Reference","title":"NearestCorrelationMatrix.DirectProjection","text":"DirectProjection(; tau=eps())\n\nSingle step projection of the input matrix into the set of correlation matrices. Useful when a \"close\" correlation matrix is needed without concern for it being the most optimal.\n\nParameters\n\ntau: a tuning parameter controlling the smallest eigenvalue of the resulting matrix\n\n\n\n\n\n","category":"type"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"NearestCorrelationMatrix.nearest_cor\nNearestCorrelationMatrix.nearest_cor!","category":"page"},{"location":"main_functions/#NearestCorrelationMatrix.nearest_cor","page":"API Reference","title":"NearestCorrelationMatrix.nearest_cor","text":"nearest_cor(A, alg; kwargs...)\n\nReturn the nearest positive definite correlation matrix to A.\n\nThis is a \"batteries included\" method, and is designed to just work with as little thought as possible. Unlike solve!, this method will return the nearest correlation matrix directly instead of a NCMSolution object. Additionally the solution is checked to be positive definite, and corrected if it is not.\n\nExamples\n\njulia> import LinearAlgebra: isposdef\n\njulia> r = [\n    1.00 0.82 0.56 0.44\n    0.82 1.00 0.28 0.85\n    0.56 0.28 1.00 0.22\n    0.44 0.85 0.22 1.00\n];\n\njulia> isposdef(r)\nfalse\n\njulia> p = nearest_cor(r)\n4×4 Matrix{Float64}:\n 1.0       0.817095  0.559306  0.440514\n 0.817095  1.0       0.280196  0.847352\n 0.559306  0.280196  1.0       0.219582\n 0.440514  0.847352  0.219582  1.0\n\njulia> isposdef(p)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#NearestCorrelationMatrix.nearest_cor!","page":"API Reference","title":"NearestCorrelationMatrix.nearest_cor!","text":"nearest_cor!(A, alg=nothing; kwargs...)\n\nReturn the nearest positive definite correlation matrix to A. This method will overwrite A.\n\nThis is a \"batteries included\" method, and is designed to just work with as little thought as possible. Unlike solve!, this method will return the nearest correlation matrix directly instead of a NCMSolution object. Additionally the solution is checked to be positive definite, and corrected if it is not.\n\nExamples\n\njulia> import LinearAlgebra: isposdef\n\njulia> r = [\n    1.00 0.82 0.56 0.44\n    0.82 1.00 0.28 0.85\n    0.56 0.28 1.00 0.22\n    0.44 0.85 0.22 1.00\n];\n\njulia> isposdef(r)\nfalse\n\njulia> nearest_cor!(r)\n4×4 Matrix{Float64}:\n 1.0       0.817095  0.559306  0.440514\n 0.817095  1.0       0.280196  0.847352\n 0.559306  0.280196  1.0       0.219582\n 0.440514  0.847352  0.219582  1.0\n\njulia> isposdef(r)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Simplified-Wrappers","page":"API Reference","title":"Simplified Wrappers","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"cor_nearPD\ncor_nearPD!\ncor_nearPSD\ncor_nearPSD!\ncor_fastPD\ncor_fastPD!","category":"page"},{"location":"main_functions/#Bigsimr.cor_nearPD","page":"API Reference","title":"Bigsimr.cor_nearPD","text":"cor_nearPD(X)\n\nReturn the nearest positive definite correlation matrix to X.\n\nSee also: cor_nearPSD, cor_fastPD\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_nearPD!","page":"API Reference","title":"Bigsimr.cor_nearPD!","text":"cor_nearPD!(X)\n\nSame as cor_nearPD, but saves space by overwriting the input X instead of creating a copy.\n\nSee also: cor_nearPSD!, cor_fastPD!\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_nearPSD","page":"API Reference","title":"Bigsimr.cor_nearPSD","text":"cor_nearPSD(X)\n\nReturn the nearest positive [semi-] definite correlation matrix to X.\n\nSee also: cor_nearPD, cor_fastPD\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_nearPSD!","page":"API Reference","title":"Bigsimr.cor_nearPSD!","text":"cor_nearPSD!(X)\n\nSame as cor_nearPSD, but saves space by overwriting the input X instead of creating a copy.\n\nSee also: cor_nearPD!, cor_fastPD!\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fastPD","page":"API Reference","title":"Bigsimr.cor_fastPD","text":"cor_fastPD(X[, tau])\n\nReturn a positive definite correlation matrix that is close to X. tau is a tuning parameter that controls the minimum eigenvalue of the resulting matrix. τ can be set to zero if only a positive semidefinite matrix is needed.\n\nSee also: cor_nearPD, cor_nearPSD\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Bigsimr.cor_fastPD!","page":"API Reference","title":"Bigsimr.cor_fastPD!","text":"cor_fastPD!(X[, tau])\n\nSame as cor_fastPD, but saves space by overwriting the input X instead of creating a copy.\n\nSee also: cor_nearPD!, cor_nearPSD!\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Pearson-Correlation-Matching","page":"API Reference","title":"Pearson Correlation Matching","text":"","category":"section"},{"location":"main_functions/","page":"API Reference","title":"API Reference","text":"PearsonCorrelationMatch.pearson_match\nPearsonCorrelationMatch.pearson_bounds","category":"page"},{"location":"main_functions/#PearsonCorrelationMatch.pearson_match","page":"API Reference","title":"PearsonCorrelationMatch.pearson_match","text":"pearson_match(p::Real, d1, d2; n::Real=12, m::Real=128, kwargs...)\n\nCompute the Pearson correlation coefficient to be used in a bivariate Gaussian copula.\n\nFields\n\np: The target correltation between the marginal distributions.\nd1: The first marginal distribution.\nd2: The second marginal distribution.\nn: The degree of the polynomial used to estimate the matching correlation.\nm: The number of points used in the hermite polynomial interpolation.\nkwargs: Additional keyword arguments. Currently unused.\n\nExamples\n\njulia> using Distributions\n\njulia> d1 = Beta(2, 3); d2 = Binomial(20, 0.2);\n\njulia> pearson_match(0.6, d1, d2)\n0.6127531346934495\n\n\n\n\n\npearson_match(R::AbstractMatrix{<:Real}, margins; n::Real=12, m::Real=128, kwargs...)\n\nPairwise compute the Pearson correlation coefficient to be used in a bivariate Gaussian copula. Ensures that the resulting matrix is a valid correlation matrix.\n\nFields\n\nR: The target correltation matrix of the marginal distributions.\nmargins: A list of marginal distributions.\nn: The degree of the polynomial used to estimate the matching correlation.\nm: The number of points used in the hermite polynomial interpolation.\nkwargs: Additional keyword arguments. Currently unused.\n\nExamples\n\njulia> using Distributions\n\njulia> margins = [Beta(2, 3), Uniform(0, 1), Binomial(20, 0.2)];\n\njulia> rho = [\n    1.0 0.3 0.6\n    0.3 1.0 0.4\n    0.6 0.4 1.0\n];\n\njulia> pearson_match(rho, margins)\n3×3 Matrix{Float64}:\n 1.0       0.309111  0.612753\n 0.309111  1.0       0.418761\n 0.612753  0.418761  1.0\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#PearsonCorrelationMatch.pearson_bounds","page":"API Reference","title":"PearsonCorrelationMatch.pearson_bounds","text":"pearson_bounds(d1, d2; n::Real=20, m::Real=128, kwargs...)\n\nDetermine the range of admissible Pearson correlations between two distributions.\n\nFields\n\nd1: The first marginal distribution.\nd2: The second marginal distribution.\nn: The degree of the polynomial used to estimate the bounds.\nm: The number of points used in the hermite polynomial interpolation.\nkwargs: Additional keyword arguments. Currently unused.\n\nDetails\n\nThe accuracy of the bounds depends on the degree of the polynomial and the number of hermite points. Be careful not to set the polynomial degree too high as Runge's theorem states that a polynomial of too high degree would cause oscillation at the edges of the interval and reduce accuracy.\n\nIn general raising the number of hermite points will result in better accuracy, but comes with a small performance hit. Furthermore the number of hermite points should be higher than the degree of the polynomial.\n\nExamples\n\njulia> using Distributions\n\njulia> d1 = Exponential(3.14); d2 = NegativeBinomial(20, 0.2);\n\njulia> pearson_bounds(d1, d2)\n(lower = -0.8553947509241561, upper = 0.9413665073003636)\n\n\n\n\n\npearson_bounds(margins; n::Real=12, m::Real=128, kwargs...)\n\nDetermine the range of admissible Pearson correlations pairwise between a list of distributions.\n\nFields\n\nmargins: A list of marginal distributions.\nn: The degree of the polynomial used to estimate the bounds.\nm: The number of points used in the hermite polynomial interpolation.\nkwargs: Additional keyword arguments. Currently unused.\n\nExamples\n\njulia> using Distributions\n\njulia> margins = [Exponential(3.14), NegativeBinomial(20, 0.2), LogNormal(2.718)];\n\njulia> lower, upper = pearson_bounds(margins);\n\njulia> lower\n3×3 Matrix{Float64}:\n  1.0       -0.855395  -0.488737\n -0.855395   1.0       -0.704403\n -0.488737  -0.704403   1.0\n\njulia> upper\n3×3 Matrix{Float64}:\n 1.0       0.941367  0.939671\n 0.941367  1.0       0.815171\n 0.939671  0.815171  1.0\n\n\n\n\n\n","category":"function"},{"location":"pearson_matching/#Pearson-Matching","page":"Pearson Matching","title":"Pearson Matching","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"using Bigsimr, Distributions\nusing RDatasets, DataFrames, Statistics\nusing Plots, PrettyTables\ngr()\ndf = dataset(\"datasets\", \"airquality\")[:, [:Ozone, :Temp]] |> dropmissing\nμ_Temp = mean(df.Temp)\nσ_Temp = std(df.Temp)\nμ_Ozone = mean(log.(df.Ozone))\nσ_Ozone = sqrt(mean((log.(df.Ozone) .- mean(log.(df.Ozone))).^2))\nmargins = [Normal(μ_Temp, σ_Temp), LogNormal(μ_Ozone, σ_Ozone)]","category":"page"},{"location":"pearson_matching/#Correlation-Conversion","page":"Pearson Matching","title":"Correlation Conversion","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Let's say we really wanted to estimate the Spearman correlation between the temperature and ozone.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"spearman_corr = cor(Spearman, Matrix(df))\ncor_bounds(margins[1], margins[2], Spearman)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"If we just use the Spearman correlation when we simulate data, then the errors are double.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"The NORTA algorithm is expecting a Pearson correlation\nThe non-linear transformation in the NORTA step does not guarantee that the input correlation is the same as the output.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Here is what we get when we use the Spearman correlation directly with no transformation:","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"x2 = rvec(1_000_000, spearman_corr, margins);\ncor(Spearman, x2)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Let's try to address problem 1 and convert the Spearman correlation to a Pearson correlation.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"adjusted_spearman_corr = cor_convert(spearman_corr, Spearman, Pearson);\nx3 = rvec(1_000_000, adjusted_spearman_corr, margins);\ncor(Spearman, x3)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Notice that the estimated Spearman correlation is essentially the same as the target Spearman correlation. This is because the transformation in the NORTA step is monotonic, which means that rank-based correlations are preserved. As a consequence, we can match the Spearman correlation exactly (up to stochastic error) with an explicit transformation.","category":"page"},{"location":"pearson_matching/#Pearson-Matching-2","page":"Pearson Matching","title":"Pearson Matching","text":"","category":"section"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"We can employ a Pearson matching algorithm that determines the necessary input correlation in order to achieve the target Pearson correlation. Let's now address problem 2.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"pearson_corr = cor(Pearson, Matrix(df))","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"If we use the measured correlation directly, then the estimated correlation from the simulated data is far off:","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"x4 = rvec(1_000_000, pearson_corr, margins);\ncor(Pearson, x4)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"The estimated correlation is much too low. Let's do some Pearson matching and observe the results.","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"adjusted_pearson_corr = pearson_match(pearson_corr, margins)\nx5 = rvec(1_000_000, adjusted_pearson_corr, margins);\ncor(Pearson, x5)","category":"page"},{"location":"pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"Now the simulated data results in a correlation structure that exactly matches the target Pearson correlation!","category":"page"}]
}
