var documenterSearchIndex = {"docs":
[{"location":"details/#Details-of-Algorithms","page":"Details","title":"Details of Algorithms","text":"","category":"section"},{"location":"details/#Nearest-Correlation-Matrix","page":"Details","title":"Nearest Correlation Matrix","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"This algorithm is trying to solve the optimization problem","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"beginaligned\n    mathrmminquad  frac12 Vert G - X Vert^2 \n    mathrmstquad  X_ii = 1 quad i = 1 ldots  n \n     X in S_+^n\nendaligned","category":"page"},{"location":"details/#Pearson-Matching","page":"Details","title":"Pearson Matching","text":"","category":"section"},{"location":"details/#NORTA","page":"Details","title":"NORTA","text":"","category":"section"},{"location":"details/","page":"Details","title":"Details","text":"Given:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"A target correlation matrix, rho\nA list of marginal distributions, F","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Do:","category":"page"},{"location":"details/","page":"Details","title":"Details","text":"Generate Z_n times d = mathcalN(0 1) IID standard normal samples\nTransform Y = ZC where C is the upper Cholesky factor of rho\nTransform U = Phi(Y) where Phi(cdot) is the CDF of the standard normal distribution\nTransform X_i = F_i^-1(U_i)","category":"page"},{"location":"details/#Correlation-Conversion","page":"Details","title":"Correlation Conversion","text":"","category":"section"},{"location":"tutorial_pearson_matching/#Pearson-Matching","page":"Pearson Matching","title":"Pearson Matching","text":"","category":"section"},{"location":"tutorial_pearson_matching/","page":"Pearson Matching","title":"Pearson Matching","text":"blah","category":"page"},{"location":"utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utilities/#General-Utilities","page":"Utilities","title":"General Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"MvSim.hermite(x::Real, n::Int, probabilists::Bool=true)\nMvSim.normal_to_margin(d::UnivariateDistribution, x::AbstractArray)","category":"page"},{"location":"utilities/#MvSim.hermite","page":"Utilities","title":"MvSim.hermite","text":"hermite(x, n::Int, probabilists::Bool=true)\n\nCompute the Hermite polynomials of degree n. Compute the Probabilists' version by default.\n\nThe two definitions of the Hermite polynomials are each a rescaling of the other. Let Heₙ(x) denote the Probabilists' version, and Hₙ(x) the Physicists'. Then\n\nH_n(x) = 2^fracn2 He_nleft(sqrt2 xright)\n\nHe_n(x) = 2^-fracn2 H_nleft(fracxsqrt2right)\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Random-Multivariate-Vector-Utilities","page":"Utilities","title":"Random Multivariate Vector Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"MvSim._randn(n::Int, d::Int)\nMvSim._rmvn(n::Int, ρ::Matrix{Float64})","category":"page"},{"location":"utilities/#MvSim._randn-Tuple{Int64,Int64}","page":"Utilities","title":"MvSim._randn","text":"_randn(n::Int, d::Int)\n\nFast parallel generation of standard normal samples.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim._rmvn-Tuple{Int64,Array{Float64,2}}","page":"Utilities","title":"MvSim._rmvn","text":"_rmvn(n::Int, ρ::Matrix{Float64})\n\nFast parallel generation of multivariate standard normal samples.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Pearson-Matching-Utilities","page":"Utilities","title":"Pearson Matching Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"MvSim.get_coefs(margin::UnivariateDistribution, n::Int)\nMvSim.Hϕ(x::Real, n::Int)\nMvSim.Gn0d(n::Int, A, B, α, β, σAσB_inv)\nMvSim.Gn0m(n::Int, A, α, dB, σAσB_inv)\nMvSim.solve_poly_pm_one(coef)","category":"page"},{"location":"utilities/#MvSim.get_coefs-Tuple{Distribution{Univariate,S} where S<:ValueSupport,Int64}","page":"Utilities","title":"MvSim.get_coefs","text":"get_coefs(margin::UnivariateDistribution, n::Int)\n\nGet the n^th degree Hermite Polynomial expansion coefficients for F^-1Φ() where F^-1 is the inverse CDF of a probability distribution and Φ(⋅) is the CDF of a standard normal distribution.\n\nNotes\n\nThe paper describes using Guass-Hermite quadrature using the Probabilists' version of the Hermite polynomials, while the package FastGaussQuadrature.jl uses the Physicists' version. Because of this, we need to do a rescaling of the input and the output:\n\nfrac1ksum_s=1^mw_s H_k (t_s) F_i^-1leftPhi(t_s)right \nfrac1sqrtpi cdot ksum_s=1^mw_s H_k (t_ssqrt2) F_i^-1leftPhi(t_s)right\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.Hϕ-Tuple{Real,Int64}","page":"Utilities","title":"MvSim.Hϕ","text":"Hϕ(x::T, n::Int) where T<:Real\n\nWe need to account for when x is ±∞ otherwise Julia will return NaN for 0×∞\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.Gn0d-Tuple{Int64,Any,Any,Any,Any,Any}","page":"Utilities","title":"MvSim.Gn0d","text":"Gn0d(::Int, A, B, α, β, σAσB_inv)\n\nCalculate the n^th derivative of G at 0 where ρ_x = G(ρ_z)\n\nWe are essentially calculating a double integral over a rectangular region\n\nint_α_r-1^α_r int_β_s-1^β_s Φ(z_i z_j ρ_z) dz_i dz_j\n\n(α[r], β[s+1]) +----------+ (α[r+1], β[s+1])\n               |          |\n               |          |\n               |          |\n  (α[r], β[s]) +----------+ (α[r+1], β[s])\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.Gn0m-Tuple{Int64,Any,Any,Any,Any}","page":"Utilities","title":"MvSim.Gn0m","text":"Gn0m(::Int, A, α, dB, σAσB_inv)\n\nCalculate the n^th derivative of G at 0 where ρ_x = G(ρ_z)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.solve_poly_pm_one-Tuple{Any}","page":"Utilities","title":"MvSim.solve_poly_pm_one","text":"solve_poly_pm_one(coef)\n\nSolve a polynomial equation on the interval [-1, 1].\n\n\n\n\n\n","category":"method"},{"location":"utilities/#Nearest-Positive-Definite-Correlation-Matrix-Utilities","page":"Utilities","title":"Nearest Positive Definite Correlation Matrix Utilities","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"MvSim.npd_gradient(y::Vector{Float64}, λ₀::Vector{Float64}, P::Matrix{Float64}, b₀::Vector{Float64}, n::Int)\nMvSim.npd_pca(X::Matrix{Float64}, λ::Vector{Float64}, P::Matrix{Float64}, n::Int)\nMvSim.npd_pre_cg(b::Vector{Float64}, c::Vector{Float64}, Ω₀::Matrix{Float64}, P::Matrix{Float64}, ϵ::Float64, N::Int, n::Int)\nMvSim.npd_precond_matrix(Ω₀::Matrix{Float64}, P::Matrix{Float64}, n::Int)\nMvSim.npd_set_omega(λ::Vector{Float64}, n::Int)\nMvSim.npd_jacobian(x::Vector{Float64}, Ω₀::Matrix{Float64}, P::Matrix{Float64}, n::Int; PERTURBATION::Float64=1e-9)","category":"page"},{"location":"utilities/#MvSim.npd_gradient-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,1},Int64}","page":"Utilities","title":"MvSim.npd_gradient","text":"npd_gradient(y::Vector{Float64}, λ₀::Vector{Float64}, P::Matrix{Float64}, b₀::Vector{Float64}, n::Int)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.npd_pca-Tuple{Array{Float64,2},Array{Float64,1},Array{Float64,2},Int64}","page":"Utilities","title":"MvSim.npd_pca","text":"npd_pca(X::Matrix{Float64}, λ::Vector{Float64}, P::Matrix{Float64}, n::Int)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.npd_pre_cg-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,2},Array{Float64,2},Float64,Int64,Int64}","page":"Utilities","title":"MvSim.npd_pre_cg","text":"npd_pre_cg(b::Vector{Float64}, c::Vector{Float64}, Ω₀::Matrix{Float64}, P::Matrix{Float64}, ϵ::Float64, N::Int, n::Int)\n\nPre- Conjugate Gradient method.\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.npd_precond_matrix-Tuple{Array{Float64,2},Array{Float64,2},Int64}","page":"Utilities","title":"MvSim.npd_precond_matrix","text":"npd_precond_matrix(Ω₀::Matrix{Float64}, P::Matrix{Float64}, n::Int)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.npd_set_omega-Tuple{Array{Float64,1},Int64}","page":"Utilities","title":"MvSim.npd_set_omega","text":"npd_set_omega(λ::Vector{Float64}, n::Int)\n\n\n\n\n\n","category":"method"},{"location":"utilities/#MvSim.npd_jacobian-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Int64}","page":"Utilities","title":"MvSim.npd_jacobian","text":"npd_jacobian(x, Ω₀, P, n; PERTURBATION=1e-9)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"function_index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#MvSim.jl-Package","page":"MvSim.jl","title":"MvSim.jl Package","text":"","category":"section"},{"location":"","page":"MvSim.jl","title":"MvSim.jl","text":"The MvSim package provides a helpful set of tools for simulating high-dimensional multivariate data with arbitrary marginal distributions. Particularly, MvSim implements:","category":"page"},{"location":"","page":"MvSim.jl","title":"MvSim.jl","text":"Simulation of multivariate data via Gaussian copulas (NORTA algorithm)\nConverting between different types of correlations (Pearson, Spearman, and Kendall)\nComputing the nearest positive definite correlation matrix (quadratically convergent algorithm)\nPearson correlation matching to account for non-linear transformations\nGenerating random positive semi-definite correlation matrices","category":"page"},{"location":"main_functions/#Main-Functions","page":"Main Functions","title":"Main Functions","text":"","category":"section"},{"location":"main_functions/#Random-Multivariate-Vector","page":"Main Functions","title":"Random Multivariate Vector","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"MvDistribution\nrvec\nBase.rand(D::MvDistribution, n::Int)","category":"page"},{"location":"main_functions/#MvSim.MvDistribution","page":"Main Functions","title":"MvSim.MvDistribution","text":"MvDistribution(R, margins, C)\n\nSimple data structure for storing a multivariate mixed distribution.\n\n\n\n\n\n","category":"type"},{"location":"main_functions/#MvSim.rvec","page":"Main Functions","title":"MvSim.rvec","text":"rvec(n, ρ, margins)\n\nGenerate samples for a list of marginal distributions and a correaltion structure.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Base.rand-Tuple{MvDistribution,Int64}","page":"Main Functions","title":"Base.rand","text":"rand(D::MvDistribution, n::Int)\n\nMore general wrapper for rvec.\n\n\n\n\n\n","category":"method"},{"location":"main_functions/#Correlations","page":"Main Functions","title":"Correlations","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"cor\ncor_convert\ncor_nearPD(R::Matrix{Float64};\n    τ::Float64=1e-5,\n    iter_outer::Int=200,\n    iter_inner::Int=20,\n    N::Int=200,\n    err_tol::Float64=1e-6,\n    precg_err_tol::Float64=1e-2,\n    newton_err_tol::Float64=1e-4)\ncor_nearPSD(A::Matrix{T}; n_iter::Int=3) where {T<:Real}\ncor_randPSD","category":"page"},{"location":"main_functions/#Statistics.cor","page":"Main Functions","title":"Statistics.cor","text":"cor(x, ::Type{<:Correlation})\n\nCompute the correlation matrix. The possible correlation     types are Pearson, Spearman, or Kendall.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#MvSim.cor_convert","page":"Main Functions","title":"MvSim.cor_convert","text":"cor_convert(ρ::Real, from::Correlation, to::Correlation)\n\nConvert from one type of correlation matrix to another. The possible correlation types are Pearson, Spearman, or Kendall.\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#MvSim.cor_nearPD-Tuple{Array{Float64,2}}","page":"Main Functions","title":"MvSim.cor_nearPD","text":"cor_nearPD(R::Matrix{Float64};\n    τ::Float64=1e-5,\n    iter_outer::Int=200,\n    iter_inner::Int=20,\n    N::Int=200,\n    err_tol::Float64=1e-6,\n    precg_err_tol::Float64=1e-2,\n    newton_err_tol::Float64=1e-4)\n\nCompute the nearest positive definite correlation matrix given a symmetric correlation matrix R. This algorithm is based off of work by Qi and Sun 2006. Matlab, C, R, and Python code can be found on Sun's page. The algorithm has also been implemented in Fortran in the NAG library.\n\nArguments\n\nτ::Float64: a [small] nonnegative number used to enforce a minimum eigenvalue.\nerr_tol::Float64: the error tolerance for the stopping condition.\n\nExamples\n\nimport LinearAlgebra: eigvals\n# Define a negative definite correlation matrix\nρ = [1.00 0.82 0.56 0.44\n     0.82 1.00 0.28 0.85\n     0.56 0.28 1.00 0.22\n     0.44 0.85 0.22 1.00]\neigvals(ρ)\n\nr = cor_nearPD(ρ)\neigvals(r)\n\n\n\n\n\n","category":"method"},{"location":"main_functions/#MvSim.cor_nearPSD-Union{Tuple{Array{T,2}}, Tuple{T}} where T<:Real","page":"Main Functions","title":"MvSim.cor_nearPSD","text":"cor_nearPSD(A::Matrix{T}; n_iter::Int=100) where {T<:Real}\n\nExamples\n\nimport LinearAlgebra: eigvals\n# Define a negative definite correlation matrix\nρ = [\n    1.00 0.82 0.56 0.44\n    0.82 1.00 0.28 0.85\n    0.56 0.28 1.00 0.22\n    0.44 0.85 0.22 1.00\n]\neigvals(ρ)\n\nr = cor_nearPSD(ρ, n_iter=100)\neigvals(r)\n\n\n\n\n\n","category":"method"},{"location":"main_functions/#MvSim.cor_randPSD","page":"Main Functions","title":"MvSim.cor_randPSD","text":"cor_randPSD(T::Type{<:AbstractFloat}, d::Int, k::Int=d)\n\nCompute a random positive semidefinite correlation matrix\n\nReference\n\nhttps://stats.stackexchange.com/a/125020\nhttps://www.sciencedirect.com/science/article/pii/S0047259X09000876\n\n\n\n\n\n","category":"function"},{"location":"main_functions/#Pearson-Matching","page":"Main Functions","title":"Pearson Matching","text":"","category":"section"},{"location":"main_functions/","page":"Main Functions","title":"Main Functions","text":"pearson_match(ρx::Real, dA::UnivariateDistribution, dB::UnivariateDistribution; n::Int=7)\npearson_match(D::MvDistribution; n::Int=7)\npearson_bounds","category":"page"},{"location":"main_functions/#MvSim.pearson_match-Tuple{Real,Distribution{Univariate,S} where S<:ValueSupport,Distribution{Univariate,S} where S<:ValueSupport}","page":"Main Functions","title":"MvSim.pearson_match","text":"pearson_match(ρ::Real, dA::UD, dB::UD; n::Int=7)\n\nCompute the pearson correlation coefficient that is necessary to achieve the target correlation given a pair of marginal distributions.\n\n\n\n\n\n","category":"method"},{"location":"main_functions/#MvSim.pearson_match-Tuple{MvDistribution}","page":"Main Functions","title":"MvSim.pearson_match","text":"pearson_match(D::MvDistribution; n::Int=7)\n\n\n\n\n\n","category":"method"},{"location":"tutorial_getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorial_getting_started/","page":"Getting Started","title":"Getting Started","text":"blah","category":"page"}]
}
